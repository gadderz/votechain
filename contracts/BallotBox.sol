// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./VoteToken.sol";

contract BallotBox is AccessControl {
    using ECDSA for bytes32;
    
    bytes32 public constant ELECTION_ADMIN = keccak256("ELECTION_ADMIN");
    
    struct Vote {
        bytes32 encryptedVote;
        uint256 timestamp;
    }
    
    VoteToken public voteToken;
    uint256 public electionId;
    
    mapping(address => bool) public hasVoted;
    mapping(uint256 => uint256) public voteCounts; // candidateId -> vote count
    mapping(bytes32 => bool) public nullifiers; // Prevents double voting with ZK proofs
    
    event VoteCast(address indexed voter, bytes32 encryptedVote);
    event ResultsTallied(uint256[] candidateIds, uint256[] votes);
    
    constructor(address _voteTokenAddress, uint256 _electionId) {
        voteToken = VoteToken(_voteTokenAddress);
        electionId = _electionId;
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ELECTION_ADMIN, msg.sender);
    }
    
    function voteBasic(uint256 candidateId, bytes32 secret) external {
        require(voteToken.balanceOf(msg.sender) > 0, "No voting token");
        require(!hasVoted[msg.sender], "Already voted");
        
        // Commit phase: store hash of vote + secret
        bytes32 voteCommitment = keccak256(abi.encodePacked(candidateId, secret));
        
        hasVoted[msg.sender] = true;
        voteCounts[candidateId]++;
        
        // Burn the voting token
        voteToken.burn(voteToken.tokenOfOwnerByIndex(msg.sender, 0));
        
        emit VoteCast(msg.sender, voteCommitment);
    }
    
    // For a more advanced implementation with ZK-SNARKs, this function would verify proofs
    function voteWithZKProof(
        bytes32 encryptedVote,
        bytes calldata proof,
        bytes32 nullifier
    ) external {
        require(!nullifiers[nullifier], "Proof already used");
        
        // In a real implementation, this would verify a ZK-SNARK proof
        // For this example, we'll simulate the verification
        bool proofVerified = verifyZKProof(encryptedVote, proof, nullifier);
        require(proofVerified, "Invalid proof");
        
        nullifiers[nullifier] = true;
        
        // Decode and count the vote (in a real implementation, this would happen after reveal)
        uint256 candidateId = decodeVote(encryptedVote);
        voteCounts[candidateId]++;
        
        emit VoteCast(msg.sender, encryptedVote);
    }
    
    // Placeholder for ZK proof verification - would integrate with a library like ZoKrates
    function verifyZKProof(
        bytes32 encryptedVote,
        bytes calldata proof,
        bytes32 nullifier
    ) internal pure returns (bool) {
        // In a real implementation, this would verify the ZK-SNARK proof
        // For demonstration purposes, we'll return true
        // Actual implementation would use a verifier contract generated by ZoKrates
        return true;
    }
    
    // Placeholder for vote decoding - would be part of the ZK system
    function decodeVote(bytes32 encryptedVote) internal pure returns (uint256) {
        // In a real implementation, this would decode the vote after the reveal phase
        // or use homomorphic encryption for tallying
        return uint256(encryptedVote) % 1000; // Simple example
    }
    
    function getResults() external view returns (uint256[] memory, uint256[] memory) {
        // This would return all candidate IDs and their vote counts
        // In a real implementation, we'd need to know the candidate IDs in advance
        uint256[] memory candidateIds = new uint256[](10);
        uint256[] memory counts = new uint256[](10);
        
        for (uint256 i = 0; i < 10; i++) {
            candidateIds[i] = i;
            counts[i] = voteCounts[i];
        }
        
        return (candidateIds, counts);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}